/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const UmlDiagramTerminals = {
    WS: /\s+/,
    LANGIUM_BOOL: /true|false/,
    LANGIUM_INT: /(-)?[0-9]+(\.[0-9]*)?/,
    LANGIUM_ID: /[\w_-]+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AggregationType = 'COMPOSITE' | 'NONE' | 'SHARED';

export function isAggregationType(item: unknown): item is AggregationType {
    return item === 'NONE' || item === 'SHARED' || item === 'COMPOSITE';
}

export type ClassDiagramElements = AbstractClass | Abstraction | Aggregation | Association | Class | Composition | DataType | Dependency | Enumeration | EnumerationLiteral | Generalization | InstanceSpecification | Interface | InterfaceRealization | LiteralSpecification | Operation | Package | PackageImport | PackageMerge | Parameter | PrimitiveType | Property | Realization | Relation | Slot | Substitution | Usage;

export const ClassDiagramElements = 'ClassDiagramElements';

export function isClassDiagramElements(item: unknown): item is ClassDiagramElements {
    return reflection.isInstance(item, ClassDiagramElements);
}

export type Concurrency = 'CONCURRENT' | 'GUARDED' | 'SEQUENTIAL';

export function isConcurrency(item: unknown): item is Concurrency {
    return item === 'SEQUENTIAL' || item === 'GUARDED' || item === 'CONCURRENT';
}

export type DataTypeReference = Class | DataType | Enumeration | Interface | PrimitiveType;

export const DataTypeReference = 'DataTypeReference';

export function isDataTypeReference(item: unknown): item is DataTypeReference {
    return reflection.isInstance(item, DataTypeReference);
}

export type EffectType = 'CREATE' | 'DELETE' | 'READ' | 'UPDATE';

export function isEffectType(item: unknown): item is EffectType {
    return item === 'CREATE' || item === 'READ' || item === 'UPDATE' || item === 'DELETE';
}

export type ElementWithSizeAndPosition = Entity;

export const ElementWithSizeAndPosition = 'ElementWithSizeAndPosition';

export function isElementWithSizeAndPosition(item: unknown): item is ElementWithSizeAndPosition {
    return reflection.isInstance(item, ElementWithSizeAndPosition);
}

export type Entity = Class | DataType | Enumeration | InstanceSpecification | Interface | Package | PrimitiveType;

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export type MetaInfo = Position | Size;

export const MetaInfo = 'MetaInfo';

export function isMetaInfo(item: unknown): item is MetaInfo {
    return reflection.isInstance(item, MetaInfo);
}

export type PackageDiagramElements = Abstraction | Class | Dependency | Package | PackageImport | PackageMerge | Usage;

export const PackageDiagramElements = 'PackageDiagramElements';

export function isPackageDiagramElements(item: unknown): item is PackageDiagramElements {
    return reflection.isInstance(item, PackageDiagramElements);
}

export type ParameterDirection = 'IN' | 'INOUT' | 'OUT' | 'RETURN';

export function isParameterDirection(item: unknown): item is ParameterDirection {
    return item === 'IN' || item === 'OUT' || item === 'INOUT' || item === 'RETURN';
}

export type RelationType = 'ABSTRACTION' | 'AGGREGATION' | 'ASSOCIATION' | 'COMPOSITION' | 'DEPENDENCY' | 'ELEMENT_IMPORT' | 'GENERALIZATION' | 'INTERFACE_REALIZATION' | 'PACKAGE_IMPORT' | 'PACKAGE_MERGE' | 'REALIZATION' | 'SUBSTITUTION' | 'USAGE';

export function isRelationType(item: unknown): item is RelationType {
    return item === 'ABSTRACTION' || item === 'AGGREGATION' || item === 'ASSOCIATION' || item === 'COMPOSITION' || item === 'DEPENDENCY' || item === 'GENERALIZATION' || item === 'INTERFACE_REALIZATION' || item === 'PACKAGE_IMPORT' || item === 'ELEMENT_IMPORT' || item === 'PACKAGE_MERGE' || item === 'REALIZATION' || item === 'SUBSTITUTION' || item === 'USAGE';
}

export type SlotDefiningFeature = Class | Interface | Property;

export const SlotDefiningFeature = 'SlotDefiningFeature';

export function isSlotDefiningFeature(item: unknown): item is SlotDefiningFeature {
    return reflection.isInstance(item, SlotDefiningFeature);
}

export type UnionType_0 = ClassDiagram | PackageDiagram | StateMachineDiagram;

export const UnionType_0 = 'UnionType_0';

export function isUnionType_0(item: unknown): item is UnionType_0 {
    return reflection.isInstance(item, UnionType_0);
}

export type Visibility = 'PACKAGE' | 'PRIVATE' | 'PROTECTED' | 'PUBLIC';

export function isVisibility(item: unknown): item is Visibility {
    return item === 'PUBLIC' || item === 'PRIVATE' || item === 'PROTECTED' || item === 'PACKAGE';
}

export interface Class extends AstNode {
    readonly $type: 'AbstractClass' | 'Class';
    __id: string
    isAbstract: boolean
    isActive: boolean
    name: string
    operations: Array<Operation>
    properties: Array<Property>
    skip: boolean
    visibility: Visibility
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface ClassDiagram extends AstNode {
    readonly $container: Diagram;
    readonly $type: 'ClassDiagram';
    __id: string
    diagramType: 'CLASS'
    entities: Array<Entity>
    relations: Array<Relation>
}

export const ClassDiagram = 'ClassDiagram';

export function isClassDiagram(item: unknown): item is ClassDiagram {
    return reflection.isInstance(item, ClassDiagram);
}

export interface DataType extends AstNode {
    readonly $container: ClassDiagram | Package | PackageDiagram;
    readonly $type: 'DataType';
    __id: string
    isAbstract: boolean
    name: string
    operations: Array<Operation>
    properties: Array<Property>
    visibility?: Visibility
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface Diagram extends AstNode {
    readonly $type: 'Diagram';
    diagram: UnionType_0
    metaInfos: Array<MetaInfo>
}

export const Diagram = 'Diagram';

export function isDiagram(item: unknown): item is Diagram {
    return reflection.isInstance(item, Diagram);
}

export interface Enumeration extends AstNode {
    readonly $container: ClassDiagram | Package | PackageDiagram;
    readonly $type: 'Enumeration';
    __id: string
    name: string
    values: Array<EnumerationLiteral>
}

export const Enumeration = 'Enumeration';

export function isEnumeration(item: unknown): item is Enumeration {
    return reflection.isInstance(item, Enumeration);
}

export interface EnumerationLiteral extends AstNode {
    readonly $container: Enumeration;
    readonly $type: 'EnumerationLiteral';
    __id: string
    name: string
    value?: string
    visibility?: Visibility
}

export const EnumerationLiteral = 'EnumerationLiteral';

export function isEnumerationLiteral(item: unknown): item is EnumerationLiteral {
    return reflection.isInstance(item, EnumerationLiteral);
}

export interface InstanceSpecification extends AstNode {
    readonly $container: ClassDiagram | Package | PackageDiagram;
    readonly $type: 'InstanceSpecification';
    __id: string
    name: string
    slots: Array<Slot>
    visibility?: Visibility
}

export const InstanceSpecification = 'InstanceSpecification';

export function isInstanceSpecification(item: unknown): item is InstanceSpecification {
    return reflection.isInstance(item, InstanceSpecification);
}

export interface Interface extends AstNode {
    readonly $container: ClassDiagram | Package | PackageDiagram;
    readonly $type: 'Interface';
    __id: string
    name: string
    operations: Array<Operation>
    properties: Array<Property>
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface LiteralSpecification extends AstNode {
    readonly $container: Slot;
    readonly $type: 'LiteralSpecification';
    __id: string
    name: string
    value: string
}

export const LiteralSpecification = 'LiteralSpecification';

export function isLiteralSpecification(item: unknown): item is LiteralSpecification {
    return reflection.isInstance(item, LiteralSpecification);
}

export interface Operation extends AstNode {
    readonly $container: AbstractClass | Class | DataType | Interface;
    readonly $type: 'Operation';
    __id: string
    concurrency?: Concurrency
    isAbstract: boolean
    isQuery: boolean
    isStatic: boolean
    name: string
    parameters: Array<Parameter>
    visibility?: Visibility
}

export const Operation = 'Operation';

export function isOperation(item: unknown): item is Operation {
    return reflection.isInstance(item, Operation);
}

export interface Package extends AstNode {
    readonly $container: ClassDiagram | Package | PackageDiagram;
    readonly $type: 'Package';
    __id: string
    entities: Array<Entity>
    name: string
    uri?: string
    visibility?: Visibility
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface PackageDiagram extends AstNode {
    readonly $container: Diagram;
    readonly $type: 'PackageDiagram';
    __id: string
    diagramType: 'PACKAGE'
    entities: Array<Entity>
    relations: Array<Relation>
}

export const PackageDiagram = 'PackageDiagram';

export function isPackageDiagram(item: unknown): item is PackageDiagram {
    return reflection.isInstance(item, PackageDiagram);
}

export interface Parameter extends AstNode {
    readonly $container: Operation;
    readonly $type: 'Parameter';
    __id: string
    direction?: ParameterDirection
    effect?: EffectType
    isException: boolean
    isOrdered: boolean
    isStream: boolean
    isUnique: boolean
    multiplicity?: string
    name: string
    parameterType?: Reference<DataTypeReference>
    visibility?: Visibility
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface Position extends AstNode {
    readonly $container: Diagram;
    readonly $type: 'Position';
    __id: string
    element: Reference<ElementWithSizeAndPosition>
    x: number
    y: number
}

export const Position = 'Position';

export function isPosition(item: unknown): item is Position {
    return reflection.isInstance(item, Position);
}

export interface PrimitiveType extends AstNode {
    readonly $container: ClassDiagram | Package | PackageDiagram;
    readonly $type: 'PrimitiveType';
    __id: string
    name: string
}

export const PrimitiveType = 'PrimitiveType';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return reflection.isInstance(item, PrimitiveType);
}

export interface Property extends AstNode {
    readonly $container: AbstractClass | Class | DataType | Interface;
    readonly $type: 'Property';
    __id: string
    aggregation?: AggregationType
    isDerived: boolean
    isDerivedUnion: boolean
    isOrdered: boolean
    isReadOnly: boolean
    isStatic: boolean
    isUnique: boolean
    multiplicity?: string
    name: string
    propertyType?: Reference<DataTypeReference>
    visibility?: Visibility
}

export const Property = 'Property';

export function isProperty(item: unknown): item is Property {
    return reflection.isInstance(item, Property);
}

export interface Relation extends AstNode {
    readonly $type: 'Abstraction' | 'Aggregation' | 'Association' | 'Composition' | 'Dependency' | 'Generalization' | 'InterfaceRealization' | 'PackageImport' | 'PackageMerge' | 'Realization' | 'Relation' | 'Substitution' | 'Usage';
    __id: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
}

export const Relation = 'Relation';

export function isRelation(item: unknown): item is Relation {
    return reflection.isInstance(item, Relation);
}

export interface Size extends AstNode {
    readonly $container: Diagram;
    readonly $type: 'Size';
    __id: string
    element: Reference<ElementWithSizeAndPosition>
    height: number
    width: number
}

export const Size = 'Size';

export function isSize(item: unknown): item is Size {
    return reflection.isInstance(item, Size);
}

export interface Slot extends AstNode {
    readonly $container: InstanceSpecification;
    readonly $type: 'Slot';
    __id: string
    definingFeature?: Reference<SlotDefiningFeature>
    name: string
    values: Array<LiteralSpecification>
}

export const Slot = 'Slot';

export function isSlot(item: unknown): item is Slot {
    return reflection.isInstance(item, Slot);
}

export interface StateMachineDiagram extends AstNode {
    readonly $container: Diagram;
    readonly $type: 'StateMachineDiagram';
    __id: string
    diagramType: 'STATE_MACHINE'
}

export const StateMachineDiagram = 'StateMachineDiagram';

export function isStateMachineDiagram(item: unknown): item is StateMachineDiagram {
    return reflection.isInstance(item, StateMachineDiagram);
}

export interface Test extends AstNode {
    readonly $type: 'Test';
    __id: string
    name: string
}

export const Test = 'Test';

export function isTest(item: unknown): item is Test {
    return reflection.isInstance(item, Test);
}

export interface AbstractClass extends Class {
    readonly $type: 'AbstractClass';
    __id: string
    isAbstract: boolean
    isActive: boolean
    label: string
    name: string
    operations: Array<Operation>
    properties: Array<Property>
    skip: boolean
    visibility: Visibility
}

export const AbstractClass = 'AbstractClass';

export function isAbstractClass(item: unknown): item is AbstractClass {
    return reflection.isInstance(item, AbstractClass);
}

export interface Abstraction extends Relation {
    readonly $type: 'Abstraction';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const Abstraction = 'Abstraction';

export function isAbstraction(item: unknown): item is Abstraction {
    return reflection.isInstance(item, Abstraction);
}

export interface Aggregation extends Relation {
    readonly $type: 'Aggregation';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    sourceAggregation?: AggregationType
    sourceMultiplicity?: string
    sourceName?: string
    target: Reference<Entity>
    targetAggregation?: AggregationType
    targetMultiplicity?: string
    targetName?: string
    visibility?: Visibility
}

export const Aggregation = 'Aggregation';

export function isAggregation(item: unknown): item is Aggregation {
    return reflection.isInstance(item, Aggregation);
}

export interface Association extends Relation {
    readonly $type: 'Association';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    sourceAggregation?: AggregationType
    sourceMultiplicity?: string
    sourceName?: string
    target: Reference<Entity>
    targetAggregation?: AggregationType
    targetMultiplicity?: string
    targetName?: string
    visibility?: Visibility
}

export const Association = 'Association';

export function isAssociation(item: unknown): item is Association {
    return reflection.isInstance(item, Association);
}

export interface Composition extends Relation {
    readonly $type: 'Composition';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    sourceAggregation?: AggregationType
    sourceMultiplicity?: string
    sourceName?: string
    target: Reference<Entity>
    targetAggregation?: AggregationType
    targetMultiplicity?: string
    targetName?: string
    visibility?: Visibility
}

export const Composition = 'Composition';

export function isComposition(item: unknown): item is Composition {
    return reflection.isInstance(item, Composition);
}

export interface Dependency extends Relation {
    readonly $type: 'Dependency';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const Dependency = 'Dependency';

export function isDependency(item: unknown): item is Dependency {
    return reflection.isInstance(item, Dependency);
}

export interface Generalization extends Relation {
    readonly $type: 'Generalization';
    __id: string
    isSubstitutable: boolean
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
}

export const Generalization = 'Generalization';

export function isGeneralization(item: unknown): item is Generalization {
    return reflection.isInstance(item, Generalization);
}

export interface InterfaceRealization extends Relation {
    readonly $type: 'InterfaceRealization';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const InterfaceRealization = 'InterfaceRealization';

export function isInterfaceRealization(item: unknown): item is InterfaceRealization {
    return reflection.isInstance(item, InterfaceRealization);
}

export interface PackageImport extends Relation {
    readonly $type: 'PackageImport';
    __id: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const PackageImport = 'PackageImport';

export function isPackageImport(item: unknown): item is PackageImport {
    return reflection.isInstance(item, PackageImport);
}

export interface PackageMerge extends Relation {
    readonly $type: 'PackageMerge';
    __id: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
}

export const PackageMerge = 'PackageMerge';

export function isPackageMerge(item: unknown): item is PackageMerge {
    return reflection.isInstance(item, PackageMerge);
}

export interface Realization extends Relation {
    readonly $type: 'Realization';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const Realization = 'Realization';

export function isRealization(item: unknown): item is Realization {
    return reflection.isInstance(item, Realization);
}

export interface Substitution extends Relation {
    readonly $type: 'Substitution';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const Substitution = 'Substitution';

export function isSubstitution(item: unknown): item is Substitution {
    return reflection.isInstance(item, Substitution);
}

export interface Usage extends Relation {
    readonly $type: 'Usage';
    __id: string
    name?: string
    relationType: RelationType
    source: Reference<Entity>
    target: Reference<Entity>
    visibility?: Visibility
}

export const Usage = 'Usage';

export function isUsage(item: unknown): item is Usage {
    return reflection.isInstance(item, Usage);
}

export type UmlDiagramAstType = {
    AbstractClass: AbstractClass
    Abstraction: Abstraction
    Aggregation: Aggregation
    Association: Association
    Class: Class
    ClassDiagram: ClassDiagram
    ClassDiagramElements: ClassDiagramElements
    Composition: Composition
    DataType: DataType
    DataTypeReference: DataTypeReference
    Dependency: Dependency
    Diagram: Diagram
    ElementWithSizeAndPosition: ElementWithSizeAndPosition
    Entity: Entity
    Enumeration: Enumeration
    EnumerationLiteral: EnumerationLiteral
    Generalization: Generalization
    InstanceSpecification: InstanceSpecification
    Interface: Interface
    InterfaceRealization: InterfaceRealization
    LiteralSpecification: LiteralSpecification
    MetaInfo: MetaInfo
    Operation: Operation
    Package: Package
    PackageDiagram: PackageDiagram
    PackageDiagramElements: PackageDiagramElements
    PackageImport: PackageImport
    PackageMerge: PackageMerge
    Parameter: Parameter
    Position: Position
    PrimitiveType: PrimitiveType
    Property: Property
    Realization: Realization
    Relation: Relation
    Size: Size
    Slot: Slot
    SlotDefiningFeature: SlotDefiningFeature
    StateMachineDiagram: StateMachineDiagram
    Substitution: Substitution
    Test: Test
    UnionType_0: UnionType_0
    Usage: Usage
}

export class UmlDiagramAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractClass', 'Abstraction', 'Aggregation', 'Association', 'Class', 'ClassDiagram', 'ClassDiagramElements', 'Composition', 'DataType', 'DataTypeReference', 'Dependency', 'Diagram', 'ElementWithSizeAndPosition', 'Entity', 'Enumeration', 'EnumerationLiteral', 'Generalization', 'InstanceSpecification', 'Interface', 'InterfaceRealization', 'LiteralSpecification', 'MetaInfo', 'Operation', 'Package', 'PackageDiagram', 'PackageDiagramElements', 'PackageImport', 'PackageMerge', 'Parameter', 'Position', 'PrimitiveType', 'Property', 'Realization', 'Relation', 'Size', 'Slot', 'SlotDefiningFeature', 'StateMachineDiagram', 'Substitution', 'Test', 'UnionType_0', 'Usage'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AbstractClass: {
                return this.isSubtype(Class, supertype) || this.isSubtype(ClassDiagramElements, supertype);
            }
            case Abstraction:
            case Dependency:
            case PackageImport:
            case PackageMerge:
            case Usage: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(PackageDiagramElements, supertype) || this.isSubtype(Relation, supertype);
            }
            case Aggregation:
            case Association:
            case Composition:
            case Generalization:
            case InterfaceRealization:
            case Realization:
            case Substitution: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(Relation, supertype);
            }
            case Class: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(DataTypeReference, supertype) || this.isSubtype(Entity, supertype) || this.isSubtype(PackageDiagramElements, supertype) || this.isSubtype(SlotDefiningFeature, supertype);
            }
            case ClassDiagram:
            case PackageDiagram:
            case StateMachineDiagram: {
                return this.isSubtype(UnionType_0, supertype);
            }
            case DataType:
            case Enumeration:
            case PrimitiveType: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(DataTypeReference, supertype) || this.isSubtype(Entity, supertype);
            }
            case Entity: {
                return this.isSubtype(ElementWithSizeAndPosition, supertype);
            }
            case EnumerationLiteral:
            case LiteralSpecification:
            case Operation:
            case Parameter:
            case Relation:
            case Slot: {
                return this.isSubtype(ClassDiagramElements, supertype);
            }
            case InstanceSpecification: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(Entity, supertype);
            }
            case Interface: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(DataTypeReference, supertype) || this.isSubtype(Entity, supertype) || this.isSubtype(SlotDefiningFeature, supertype);
            }
            case Package: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(Entity, supertype) || this.isSubtype(PackageDiagramElements, supertype);
            }
            case Position:
            case Size: {
                return this.isSubtype(MetaInfo, supertype);
            }
            case Property: {
                return this.isSubtype(ClassDiagramElements, supertype) || this.isSubtype(SlotDefiningFeature, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Abstraction:source':
            case 'Abstraction:target':
            case 'Abstraction:source':
            case 'Abstraction:target':
            case 'Aggregation:source':
            case 'Aggregation:target':
            case 'Aggregation:source':
            case 'Aggregation:target':
            case 'Association:source':
            case 'Association:target':
            case 'Association:source':
            case 'Association:target':
            case 'Composition:source':
            case 'Composition:target':
            case 'Composition:source':
            case 'Composition:target':
            case 'Dependency:source':
            case 'Dependency:target':
            case 'Dependency:source':
            case 'Dependency:target':
            case 'Generalization:source':
            case 'Generalization:target':
            case 'Generalization:source':
            case 'Generalization:target':
            case 'InterfaceRealization:source':
            case 'InterfaceRealization:target':
            case 'InterfaceRealization:source':
            case 'InterfaceRealization:target':
            case 'PackageImport:source':
            case 'PackageImport:target':
            case 'PackageImport:source':
            case 'PackageImport:target':
            case 'PackageMerge:source':
            case 'PackageMerge:target':
            case 'PackageMerge:source':
            case 'PackageMerge:target':
            case 'Realization:source':
            case 'Realization:target':
            case 'Realization:source':
            case 'Realization:target':
            case 'Relation:source':
            case 'Relation:target':
            case 'Substitution:source':
            case 'Substitution:target':
            case 'Substitution:source':
            case 'Substitution:target':
            case 'Usage:source':
            case 'Usage:target':
            case 'Usage:source':
            case 'Usage:target': {
                return Entity;
            }
            case 'Parameter:parameterType':
            case 'Property:propertyType': {
                return DataTypeReference;
            }
            case 'Position:element':
            case 'Size:element': {
                return ElementWithSizeAndPosition;
            }
            case 'Slot:definingFeature': {
                return SlotDefiningFeature;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Class': {
                return {
                    name: 'Class',
                    mandatory: [
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isActive', type: 'boolean' },
                        { name: 'operations', type: 'array' },
                        { name: 'properties', type: 'array' },
                        { name: 'skip', type: 'boolean' }
                    ]
                };
            }
            case 'ClassDiagram': {
                return {
                    name: 'ClassDiagram',
                    mandatory: [
                        { name: 'entities', type: 'array' },
                        { name: 'relations', type: 'array' }
                    ]
                };
            }
            case 'DataType': {
                return {
                    name: 'DataType',
                    mandatory: [
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'operations', type: 'array' },
                        { name: 'properties', type: 'array' }
                    ]
                };
            }
            case 'Diagram': {
                return {
                    name: 'Diagram',
                    mandatory: [
                        { name: 'metaInfos', type: 'array' }
                    ]
                };
            }
            case 'Enumeration': {
                return {
                    name: 'Enumeration',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'InstanceSpecification': {
                return {
                    name: 'InstanceSpecification',
                    mandatory: [
                        { name: 'slots', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'operations', type: 'array' },
                        { name: 'properties', type: 'array' }
                    ]
                };
            }
            case 'Operation': {
                return {
                    name: 'Operation',
                    mandatory: [
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isQuery', type: 'boolean' },
                        { name: 'isStatic', type: 'boolean' },
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'Package': {
                return {
                    name: 'Package',
                    mandatory: [
                        { name: 'entities', type: 'array' }
                    ]
                };
            }
            case 'PackageDiagram': {
                return {
                    name: 'PackageDiagram',
                    mandatory: [
                        { name: 'entities', type: 'array' },
                        { name: 'relations', type: 'array' }
                    ]
                };
            }
            case 'Parameter': {
                return {
                    name: 'Parameter',
                    mandatory: [
                        { name: 'isException', type: 'boolean' },
                        { name: 'isOrdered', type: 'boolean' },
                        { name: 'isStream', type: 'boolean' },
                        { name: 'isUnique', type: 'boolean' }
                    ]
                };
            }
            case 'Property': {
                return {
                    name: 'Property',
                    mandatory: [
                        { name: 'isDerived', type: 'boolean' },
                        { name: 'isDerivedUnion', type: 'boolean' },
                        { name: 'isOrdered', type: 'boolean' },
                        { name: 'isReadOnly', type: 'boolean' },
                        { name: 'isStatic', type: 'boolean' },
                        { name: 'isUnique', type: 'boolean' }
                    ]
                };
            }
            case 'Slot': {
                return {
                    name: 'Slot',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'AbstractClass': {
                return {
                    name: 'AbstractClass',
                    mandatory: [
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isActive', type: 'boolean' },
                        { name: 'operations', type: 'array' },
                        { name: 'properties', type: 'array' },
                        { name: 'skip', type: 'boolean' }
                    ]
                };
            }
            case 'Generalization': {
                return {
                    name: 'Generalization',
                    mandatory: [
                        { name: 'isSubstitutable', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new UmlDiagramAstReflection();
